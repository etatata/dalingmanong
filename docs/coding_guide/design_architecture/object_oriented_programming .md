### 面向对象编程

1. #### 什么是面向对象编程？ 

面向对象编程（Object-Oriented Programming，简称 OOP）是一种编程范式，强调将数据和操作数据的方法组织在一起，形成对象。面向对象编程让程序员更容易地模拟现实世界中的实体和过程，以提高代码的可读性、可维护性和可重用性。

1. #### 面向对象编程的三个特性是什么？面向对象编程具有三个主要特性：封装、继承和多态。

- 封装：将数据和操作数据的方法封装在对象中，隐藏对象内部的实现细节，并通过接口与外部进行交互。封装有助于降低代码的耦合度，提高代码的可维护性。
- 继承：子类可以继承父类的属性和方法，实现代码复用。继承有助于抽象出共同特征，简化代码结构。
- 多态：允许不同类的对象通过相同的接口进行操作，实现在运行时根据对象的实际类型选择合适的方法。多态提高了代码的灵活性，降低了各个模块之间的依赖。

2. ####  如何进行面向对象编程？

- 分析和设计：分析现实世界中的问题，确定需要模拟的实体和它们之间的关系。
- 定义类和对象：创建类，为类定义属性和方法。实例化对象，为对象分配内存并初始化属性。
- 实现封装：将数据和操作数据的方法封装在对象中，通过接口与外部进行交互。
- 实现继承：使用继承关系表示类之间的层次关系，实现代码复用。
- 实现多态：允许不同类的对象通过相同的接口进行操作，实现运行时的动态分派。

3. #### 面向对象的编程有什么原则？

- 单一职责原则（Single Responsibility Principle, SRP）：一个类应该只负责一项职责。如果一个类承担了多项职责，它将变得复杂且难以维护。

- 开闭原则（Open/Closed Principle, OCP）：软件实体应该对扩展开放，对修改关闭。即在不修改现有代码的基础上，可以添加新功能或扩展现有功能。

  - 例如我现在有一个商品类Goods，这个类之前有一个方法是获取它的价格，例如：
  
    ```java
    public class Goods {
        private BigDecimal price;
        
        public void setPrice(BigDecimal price) {
            this.price = price;
        }
        public BigDecimal getPrice() {
            return this.price;
        }
    }
    ```
  
    现在`变化`来了，当前商品需要打8折进行销售，不符合开闭原则的做法就是直接`进原来的代码中进行修改`，例如直接在getter方法中修改
  
    ``` java
    public BigDecimal getPrice() {
        // BigDecimal.multiply就是乘法，BigDecimal可以防止精度丢失
        return this.price.multiply(new BigDecimal("0.8"));
    }
    ```
  
    这样显然就是不满足开闭原则的，因为我们对源代码进行了修改，如果下次是打七折，那是不是又要去改源代码呢
  
    正确的做法应该是写一个子类`DiscountGoods`来拓展父类的功能，再在子类上进行修改，这样就不会破坏父类的功能，又能满足需求
  
    ```java
    public class DiscountGoods extends Goods{
        @Override
        public BigDecimal getPrice() {
            return super.getPrice().multiply(new BigDecimal("0.8"));
        }
    }
    ```
  
    这就叫对扩展开发，对修改关闭。我们在用设计模式编码时应该时刻注意的是，改源码是一件非常危险的事情，因为一个功能并不是只有你在使用，很容易造成牵一发而动全身的效果
  
    但是如果我们因为要遵守开闭原则，每次对功能进行修改的时候，都去新写一个类，这样的会很繁琐，所以我们的准则是：
  
        如果一个类是自己写的，自己修改不会影响该类在其他地方的效果（不会牵一发而动全身），那你就可以随意修改
        如果不是自己写的，自己不清楚修改后会带来什么样的影响，那就不要修改，而要符合开闭原则


- 里氏替换原则（Liskov Substitution Principle, LSP）：子类应该可以替换父类，而不影响程序的正确性。确保继承关系的合理性，避免子类破坏父类的行为。

- 接口隔离原则（Interface Segregation Principle, ISP）：使用多个专门的接口，而不是一个通用的接口。确保接口的职责单一，提高代码的可维护性和可重用性。要面向接口编程，不要面向实现编程。

- 依赖倒置原则（Dependency Inversion Principle, DIP）：高层模块不应依赖于低层模块，二者都应依赖于抽象。降低模块之间的耦合度，提高代码的可扩展性。

  ```java
  //错误写法
  class Person {
      public void feed(Dog dog) {
          System.out.println("开始喂dog...");
      }
  }
  
  class Dog {
      public void eat() {
          System.out.println("狗啃骨头");
      }
  }
  
  // ================================================================
  //遇到问题
  public class AppTest {
      public static void main(String[] args) {
          Person person = new Person();
          Dog dog = new Dog();
          person.feed(dog);
      }
  }
  class Cat {
      public void eat() {
          System.out.println("小猫吃鱼");
      }
  }
  public class AppTest {
      public static void main(String[] args) {
          Person person = new Person();
          Dog dog = new Dog();
          Cat cat = new Cat();
          // 喂狗
          person.feed(dog);
          // 喂猫
          person.feed(cat);
      }
  }
  
  //正确写法。
  class Person {
      public void feed(Animal animal) {
          System.out.println("开始喂dog...");
      }
  }
  
  interface Animal {
      void eat();
  }
  
  class Dog implements Animal{
      @Override
      public void eat() {
          System.out.println("狗啃骨头");
      }
  }
  
  class Cat implements Animal{
      @Override
      public void eat() {
          System.out.println("小猫吃鱼");
      }
  }
  
  // ================================================================
  public class AppTest {
      public static void main(String[] args) {
          Person person = new Person();
          Dog dog = new Dog();
          Cat cat = new Cat();
          // 喂狗
          person.feed(dog);
          // 喂猫
          person.feed(cat);
      }
  }
  
  ```

  

- 迪米特法则（最少知道原则）

- 多组合少继承

  继承的主要问题是，多层继承增加理解复杂度，容易出错。组合可以灵活和清晰的表达意图。

  


4. #### 面向对象的应用场景和不适合的场景

面向对象编程的应用场景：

1. 复杂系统：面向对象编程非常适合用于构建复杂的、多层次的系统。通过对现实世界实体进行建模，OOP 可以简化复杂问题的解决过程。
2. 可扩展性：当系统需要不断添加新功能或扩展现有功能时，面向对象编程可以确保代码的可扩展性和可维护性。
3. 代码重用：面向对象编程中的继承和多态特性有助于代码重用，减少重复代码，提高开发效率。
4. 团队协作：面向对象编程可以更好地支持团队协作开发。通过封装、继承和多态等特性，可以将程序划分为独立的模块，每个团队成员可以负责一个模块的开发，降低模块间的耦合，提高开发效率。

面向对象编程不适用的场景：

1. 简单任务：对于一些简单的、独立的任务，面向对象编程可能会引入不必要的复杂性。在这种情况下，使用过程式编程或函数式编程可能更为合适。
2. 性能敏感场景：面向对象编程的抽象特性可能会导致性能损失。在性能敏感的场景下（例如实时系统、游戏引擎等），可能需要使用更底层的编程范式（如过程式编程）以获得更好的性能。
3. 内存受限场景：在内存受限的环境中（例如嵌入式系统、物联网设备等），面向对象编程可能会导致额外的内存开销。在这种情况下，采用更轻量级的编程范式可能更为合适。

5. #### 面向对象和领域渠道编程（ddd)的区别。 一个是针对代码的组织范式，一个对业务拆分的方法论。

   联系：

   1. 两者都关注于实现模型：面向对象编程和领域驱动设计都关注于建立一个反映现实世界问题的模型。它们都试图通过对现实世界实体进行建模来简化复杂问题的解决过程。
   2. 都使用对象和类：OOP 和 DDD 都使用对象和类作为其基本构建块。在面向对象编程中，我们通过创建类来表示现实世界中的实体，并使用对象作为类的实例。领域驱动设计则以领域模型为核心，这些领域模型通常也是通过对象和类来表示的。

   区别：

   1. 目的和范围：面向对象编程是一种编程范式，它关注于如何通过使用封装、继承和多态等特性将代码组织成可重用、可扩展的模块。领域驱动设计是一种软件开发方法，它关注于如何通过对问题领域进行建模，以便更好地理解和解决复杂业务问题。面向对象编程可以说是领域驱动设计的实现手段之一。
   2. 抽象层次：面向对象编程主要关注代码层面的实现，它试图通过将代码组织成类和对象来提高代码的可维护性和可扩展性。领域驱动设计则关注于业务层面的建模，它试图通过与领域专家的合作，以及使用领域特定语言（DSL）来描述问题领域，从而提高软件的业务价值。
   3. 方法论：领域驱动设计是一种方法论，它提供了一套关于领域模型、实体、值对象、聚合、领域事件等概念的指导原则。面向对象编程并不提供这些指导原则，它只是一种编程范式。

6.  面向对象编程的部分问题。
   1. 1，贫血和充血的类。

